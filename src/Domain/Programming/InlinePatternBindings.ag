-----------------------------------------------------------------------------
-- Copyright 2009, Open Universiteit Nederland. This file is distributed 
-- under the terms of the GNU General Public License. For more information, 
-- see the file "LICENSE.txt", which is included in the distribution.
-----------------------------------------------------------------------------
-- |
-- Maintainer  :  alex.gerdes@ou.nl
-- Stability   :  provisional
-- Portability :  unknown
--
-- todo : Testing: a possible test method could be to specify contracts for
--        a number of standard/complete functions and check whether the alpha
--        renamed function still satisfies the contract.
--
-----------------------------------------------------------------------------

INCLUDE "syntax/UHA_Syntax.ag"

imports{
import Data.Map hiding (map)
import Domain.Programming.Helium
import Domain.Programming.HeliumRules ()
import Domain.Programming.Utils
import Prelude hiding (lookup)
}

ATTR * [ | | result : SELF ]

ATTR RightHandSide Expression [ | env : Env | ]
ATTR Alternative Alternatives Expressions Declarations Declaration 
     FunctionBindings FunctionBinding GuardedExpression GuardedExpressions 
     MaybeDeclarations MaybeExpression Qualifier Qualifiers
     RecordExpressionBinding RecordExpressionBindings Statements Statement
     [ env : Env | | ]

SEM Body 
  | Body declarations . env = updateEnv @result empty

SEM RightHandSide 
  | Expression expression . env = updateEnv @result @lhs.env

SEM Expression
  | Variable lhs.result = case lookup @result @lhs.env of
                            Just n -> n
                            _      -> @result
  | Let expression . env = updateEnv @result @lhs.env

-- utility functions
{
type Env = Map Expression Expression

class UpdateEnv a where
  updateEnv :: a -> Env -> Env

instance UpdateEnv Body where
  updateEnv (Body_Body _ _ ds) = updateEnv' ds
instance UpdateEnv RightHandSide where
  updateEnv rhs env = 
    case rhs of
      RightHandSide_Expression _ _ w -> updateEnv' (fromMaybeDecl w) env
      _                              -> env
instance UpdateEnv Expression where
  updateEnv expr env =
    case expr of
      Expression_Let _ ds _ -> updateEnv' ds env
      _                     -> env

updateEnv' :: Declarations -> Env -> Env
updateEnv' ds env = foldr insertInEnv env ds
  where
    insertInEnv :: Declaration -> Env -> Env
    insertInEnv d env = 
      case d of
        Declaration_PatternBinding _ p 
          (RightHandSide_Expression _ expr MaybeDeclarations_Nothing) ->
            insert (pat2expr p) expr env
        _ -> env

fromMaybeDecl :: MaybeDeclarations -> Declarations
fromMaybeDecl m = case m of
                    MaybeDeclarations_Just ds -> ds
                    _                         -> []
        
inlinePatternBindings :: Module -> Module
inlinePatternBindings = fst . sem_Module
}
