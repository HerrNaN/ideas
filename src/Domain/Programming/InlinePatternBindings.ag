-----------------------------------------------------------------------------
-- Copyright 2009, Open Universiteit Nederland. This file is distributed 
-- under the terms of the GNU General Public License. For more information, 
-- see the file "LICENSE.txt", which is included in the distribution.
-----------------------------------------------------------------------------
-- |
-- Maintainer  :  alex.gerdes@ou.nl
-- Stability   :  provisional
-- Portability :  unknown
--
-- todo : Testing: a possible test method could be to specify contracts for
--        a number of standard/complete functions and check whether the alpha
--        renamed function still satisfies the contract.
--
-----------------------------------------------------------------------------

INCLUDE "syntax/UHA_Syntax.ag"

imports{
import Data.Data hiding (Fixity)
import Data.Generics.Biplate ()
import Data.Generics.PlateData
import Data.List (partition, (\\))
import Data.Map hiding (map, null, (\\))
import Domain.Programming.Helium
import Domain.Programming.HeliumRules ()
import Domain.Programming.Utils
import Prelude hiding (lookup)
}

ATTR * [ | | me : SELF result : SELF ]

ATTR RightHandSide Expression [ | env : Env | ]
ATTR Module Body
     Alternative Alternatives Expressions Declarations Declaration 
     FunctionBindings FunctionBinding GuardedExpression GuardedExpressions 
     MaybeDeclarations MaybeExpression Qualifier Qualifiers
     RecordExpressionBinding RecordExpressionBindings Statements Statement
     [ env : Env | | ]

SEM RightHandSide 
  | Expression expression . env = updateEnv @me @lhs.env
               lhs . result    = removeWhere @result -- sloop de wheres eraf

SEM Expression
  | Variable lhs . result = case lookup @me @lhs.env of
                              Just n -> n
                              _      -> @me
  | Let expression . env    = updateEnv @me @lhs.env
               lhs . result = removeLet @result

-- utility functions
{
type Env = Map Expression Expression

class UpdateEnv a where
  updateEnv :: a -> Env -> Env

instance UpdateEnv Body where
  updateEnv (Body_Body _ _ ds) = updateEnv' ds
instance UpdateEnv RightHandSide where
  updateEnv rhs env = 
    case rhs of
      RightHandSide_Expression _ _ maybeWhere ->
        case fromMaybeDecls maybeWhere of
          Just w -> updateEnv' w env
          _      -> env
      _ -> env
instance UpdateEnv Expression where
  updateEnv expr env =
    case expr of
      Expression_Let _ ds _ -> updateEnv' ds env
      _                     -> env

updateEnv' :: Declarations -> Env -> Env
updateEnv' ds env = foldr insertInEnv env ds
  where
    insertInEnv :: Declaration -> Env -> Env
    insertInEnv d env = 
      case d of
        Declaration_PatternBinding _ p 
          (RightHandSide_Expression _ expr MaybeDeclarations_Nothing) ->
            case pat2expr p of
              Just e -> insert e expr env
              _      -> error $ "InlinePatternBinding: cannot insert " ++ show p ++ " into env"
        _ -> env

inlinePatternBindings :: Env -> Module -> Module
inlinePatternBindings env m = (\(_, m, _) -> m) $ sem_Module m env

removeWhere :: RightHandSide -> RightHandSide
removeWhere rhs = 
  case rhs of
    RightHandSide_Expression r expr w -> 
      case fromMaybeDecls w of
        Just ds -> RightHandSide_Expression r expr $ 
                     MaybeDeclarations_Just $ ds \\ getPatBinds ds
        _       -> rhs
    RightHandSide_Guarded r gexpr w ->
      case fromMaybeDecls w of
        Just ds -> RightHandSide_Guarded r gexpr $ 
                     MaybeDeclarations_Just $ ds \\ getPatBinds ds
        _       -> rhs

removeLet :: Expression -> Expression
removeLet (Expression_Let r ds expr) = 
  let funBinds = ds \\ getPatBinds ds
  in if null funBinds then
       expr 
     else
       Expression_Let r funBinds expr

getPatBinds :: Data a => a -> Declarations
getPatBinds x = [ d | d@(Declaration_PatternBinding _ _ _) <- universeBi x] :: Declarations

}
