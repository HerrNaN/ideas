-----------------------------------------------------------------------------
-- Copyright 2009, Open Universiteit Nederland. This file is distributed 
-- under the terms of the GNU General Public License. For more information, 
-- see the file "LICENSE.txt", which is included in the distribution.
-----------------------------------------------------------------------------
-- |
-- Maintainer  :  alex.gerdes@ou.nl
-- Stability   :  provisional
-- Portability :  unknown
--
-- todo : Testing: a possible test method could be to specify contracts for
--        a number of standard/complete functions and check whether the alpha
--        renamed function still satisfies the contract.
--
-----------------------------------------------------------------------------

INCLUDE "staticanalysis/staticchecks/Scope.ag"
INCLUDE "syntax/UHA_Syntax.ag"

imports{
import Data.List hiding (union, insert, lookup)
import Data.Map hiding (map, filter, (\\))
import Domain.Programming.Helium
import Prelude hiding (lookup)
}

-- Set initialScope
SEM Module
  | Module loc . initialScope = [Name_Identifier noRange [] ""]

-- Copied from StaticChecks, get the names of LHSs
ATTR FunctionBinding FunctionBindings LeftHandSide [ | | name:Name ]

SEM FunctionBindings 
  | Cons  lhs . name = @hd.name
  | Nil   lhs . name = error "AlphaRenaming: empty FunctionBindings"

SEM LeftHandSide
  | Function      lhs . name = @name.self
  | Infix         lhs . name = @operator.self
  | Parenthesized lhs . name = @lefthandside.name

SEM Body 
   | Body  loc . namesInScope = @declarations.declVarNames
               . unboundNames = @declarations.unboundNames
               . scopeInfo    = ([],[],[])

-- Construct a mapping from vars to vars with fresh names
ATTR Body Module Expression RightHandSide
     RecordExpressionBinding RecordExpressionBindings
     MaybeExpression GuardedExpression FunctionBinding
     Expressions Declaration Declarations Alternative FunctionBindings
     Alternatives GuardedExpressions RecordPatternBinding
     Patterns Pattern LeftHandSide RecordPatternBindings AnnotatedType
     AnnotatedTypes Constructor Constructors FieldDeclaration FieldDeclarations 
     ContextItem Export Import ImportDeclaration MaybeName Names SimpleType
     ContextItems ImportDeclarations Imports MaybeNames Type Exports
     ImportSpecification MaybeExports Types MaybeImportSpecification
     [ nameMap : NameMap | freshNames : Names | ]

SEM Body
  | Body loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap 
                                                 @namesInScope @lhs.freshNames 

SEM MaybeDeclarations
  | Just loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap 
                                                 @namesInScope @lhs.freshNames 

SEM Expression
  | Let loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap 
                                                @namesInScope @lhs.freshNames 
           
SEM Statement
  | Let loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap 
                                                @namesInScope @lhs.freshNames   

SEM Qualifier
  | Let loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap 
                                                @namesInScope @lhs.freshNames 

-- monomorphic binding constructs
SEM FunctionBinding
  | FunctionBinding loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap 
                                                            @namesInScope @lhs.freshNames 

SEM Expression
  | Lambda loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap 
                                                   @namesInScope @lhs.freshNames 

SEM Alternative
  | Alternative loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap 
                                                        @namesInScope @lhs.freshNames 

SEM Statement
  | Generator loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap 
                                                      @namesInScope @lhs.freshNames 

SEM Qualifier
  | Generator loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap 
                                                      @namesInScope @lhs.freshNames 

-- Correct the scope for RHSs with where

ATTR MaybeDeclarations
     [ | nameMap : NameMap freshNames : Names | ]

SEM RightHandSide
  | Expression expression         . nameMap = @where.nameMap
  | Guarded    guardedexpressions . nameMap = @where.nameMap

-- might also be necessary for Statements/Qualifiers, skipping for now
ATTR Statements Statement Qualifier Qualifiers 
     [ | nameMap : NameMap freshNames : Names | ]

SEM Expression
  | Comprehension expression . nameMap = @qualifiers.nameMap
--                     qualifiers . namesInScope = @lhs.namesInScope

SEM Qualifier
  | Generator expression . nameMap = @lhs.nameMap


-- Do the renaming and make a copy of the ast
ATTR * [ fixedNames : Names | | result : SELF ]
ATTR Name [ nameMap : NameMap | | ]

SEM Name
  | Identifier Operator Special lhs.result = 
      case lookup @result @lhs.nameMap of
        Just n -> if @result `notElem` @lhs.fixedNames then n else @result
        _      -> @result

------------------------------------------------------------------------------
-- utility functions
{
type NameMap = Map Name Name

updateMap :: ScopeInfo -> NameMap -> Names -> Names -> (NameMap, Names)
updateMap si m ks vs = let (newMap, i) = insertAllInNameMap si m ks vs
                                  in (newMap, drop i vs)

insertInNameMap :: ScopeInfo -> (Name, Name) -> (NameMap, Int) -> (NameMap, Int)
insertInNameMap si (k, v) (m, i) | check = (insert k v m, i+1)
                                 | otherwise = (m, i)
  where
    --check = (notMember k m && (name2string k) `notElem` fixedNames) || isShadowed k si
    check = notMember k m || isShadowed k si

insertAllInNameMap :: ScopeInfo -> NameMap -> Names -> Names -> (NameMap, Int)
insertAllInNameMap si m ks vs = foldr (insertInNameMap si) (m, 0) $ zip ks vs

isShadowed :: Name -> ScopeInfo -> Bool
isShadowed n = elem n . map fst . (\(_,_,s)->s) 

freshNames = [Name_Identifier noRange [] ('x' : show i) | i <- [1..]]

class AlphaRenaming a where
  alphaRenaming :: Names -> a -> a
instance AlphaRenaming Module where
  alphaRenaming fixedNames m = 
    (\(_, x, _) -> x) $ sem_Module m fixedNames freshNames empty
instance AlphaRenaming Expression where
  alphaRenaming fixedNames e = 
    (\(_, x, _, _) -> x) $ sem_Expression e fixedNames freshNames empty []
instance AlphaRenaming Declaration where
  alphaRenaming fixedNames d = 
    (\(_, _, x, _, _) -> x) $ sem_Declaration d fixedNames freshNames empty []
}
