-----------------------------------------------------------------------------
-- Copyright 2009, Open Universiteit Nederland. This file is distributed 
-- under the terms of the GNU General Public License. For more information, 
-- see the file "LICENSE.txt", which is included in the distribution.
-----------------------------------------------------------------------------
-- |
-- Maintainer  :  alex.gerdes@ou.nl
-- Stability   :  provisional
-- Portability :  unknown
--
-- todo : Testing: a possible test method could be to specify contracts for
--        a number of standard/complete functions and check whether the alpha
--        renamed function still satisfies the contract.
--
-----------------------------------------------------------------------------

INCLUDE "staticanalysis/staticchecks/Scope.ag"
INCLUDE "syntax/UHA_Syntax.ag"

imports{
import Data.List hiding (union, insert, lookup)
import Data.Map hiding (map, filter, (\\))
import Domain.Programming.Helium
import Prelude hiding (lookup)
}

-- Set initialScope
SEM Module
  | Module loc . initialScope = []

-- Copied from StaticChecks, get the names of LHSs
ATTR FunctionBinding FunctionBindings LeftHandSide [ | | name:Name ]

SEM FunctionBindings 
  | Cons  lhs . name = @hd.name
  | Nil   lhs . name = error "AlphaRenaming: empty FunctionBindings"

SEM LeftHandSide
  | Function  lhs . name = @name.self
  | Infix     lhs . name = @operator.self
  | Parenthesized lhs . name = @lefthandside.name


-- Adding scope changes at certain places in the AST
SEM Body
  | Body loc . (namesInScope, unboundNames, scopeInfo) = changeOfScope @declarations.declVarNames @declarations.unboundNames @lhs.namesInScope
         lhs . unboundNames = @unboundNames


-- Construct a mapping from vars to vars with fresh names
ATTR Expression RightHandSide
     RecordExpressionBinding RecordExpressionBindings
     MaybeExpression GuardedExpression FunctionBinding
     Expressions Declaration Declarations Alternative FunctionBindings
     Alternatives GuardedExpressions RecordPatternBinding
     Patterns Pattern LeftHandSide RecordPatternBindings AnnotatedType
     AnnotatedTypes Constructor Constructors FieldDeclaration FieldDeclarations Body
     [ nameMap : NameMap | freshNames : Names | ]

SEM Module
  | Module body . nameMap    = empty 
                . freshNames = [Name_Identifier noRange [] ('x' : show i) | i <- [1..]]

SEM Body
  | Body loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames

SEM MaybeDeclarations
  | Just loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames

SEM Expression
  | Let loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames
           
SEM Statement
  | Let loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames
           
SEM Qualifier
  | Let loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames

-- monomorphic binding constructs
SEM FunctionBinding
  | FunctionBinding loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames

SEM Expression
  | Lambda loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames

SEM Alternative
  | Alternative loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames
                      
SEM Statement
  | Generator loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames

SEM Qualifier
  | Generator loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames


-- Correct the scope for RHSs with where, might also be necessary for Statements/Qualifiers, skipping for now

ATTR MaybeDeclarations Statements Statement Qualifier Qualifiers [ | nameMap : NameMap freshNames : Names | ]

SEM RightHandSide
  | Expression expression . nameMap = @where.nameMap

-- Do the renaming and make a copy of the ast
ATTR * [ | | result : SELF ]
ATTR Name [ nameMap : NameMap | | ]

SEM Name
  | Identifier Operator Special lhs.result = case lookup @result @lhs.nameMap of
                                               Just n -> n
                                               _      -> @result

-- utility functions
{
type NameMap = Map Name Name

updateMap :: ScopeInfo -> NameMap -> Names -> Names -> (NameMap, Names)
updateMap si m ks vs = let (newMap, i) = insertAllInNameMap si m ks vs
                       in (newMap, drop i vs)

insertInNameMap :: ScopeInfo -> (Name, Name) -> (NameMap, Int) -> (NameMap, Int)
insertInNameMap si (k, v) (m, i) | notMember k m  || isShadowed k si = (insert k v m, i+1)
                                 | otherwise = (m, i)

insertAllInNameMap :: ScopeInfo -> NameMap -> Names -> Names -> (NameMap, Int)
insertAllInNameMap si m ks vs = foldr (insertInNameMap si) (m, 0) $ zip ks vs

isShadowed :: Name -> ScopeInfo -> Bool
isShadowed n = elem n . map fst . (\(_,_,s)->s) 

alphaRenaming :: Module -> Module
alphaRenaming = fst . sem_Module


-- Reserved identifiers, not necessary anymore: the unbounded names are not put into the renaming scheme. 
-- I let them hang around for a while, you never know ;-)
preludeIdentifiers = ["$!","catch","!!","$","&&","++",".","=<<","Bool","False","True","Bounded","minBound","maxBound","Char","Double","Either","Left","Right","Enum","succ","pred","toEnum","fromEnum","enumFrom","enumFromThen","enumFromTo","enumFromThenTo","Eq","==","/=","FilePath","Float","Fractional","pi","exp","sqrt","log","**","logBase","sin","tan","cos","asin","atan","acos","sinh","tanh","cosh","asinh","atanh","acosh","Fractional","/","recip","fromRational","Functor","fmap","IO","IOError","Int","Integer","Integral","quot","rem","div","mod","quotRem","divMod","toInteger","Maybe","Nothing","Just","Monad",">>=",">>","return","fail","Num","+","*","-","negate","abs","signum","fromInteger","Ord","compare","<",">=",">","<=","max","min","Ordering","LT","EQ","GT","Rational","Read","readsPrec","readList","ReadS","Real","toRational","RealFloat","floatRadix","floatDigits","floatRange","decodeFloat","encodeFloat","exponent","significand","scaleFloat","isNaN","isInfinite","isDenormalized","isNegativeZero","isIEEE","atan2","RealFrac","properFraction","truncate","round","ceiling","floor","Show","showsPrec","show","showList","ShowS","String","^","^^","all","and","any","appendFile","asTypeOf","break","concat","concatMap","const","curry","cycle","drop","dropWhile","either","elem","error","even","filter","flip","foldl","foldl1","foldr","foldr1","fromIntegral","fst","gcd","getChar","getContents","getLine","head","id","init","interact","ioError","iterate","last","lcm","length","lex","lines","lookup","map","mapM","mapM_","maximum","maybe","minimum","not","notElem","null","odd","or","otherwise","print","product","putChar","putStr","putStrLn","read","readFile","readIO","readLn","readParen","reads","realToFrac","repeat","replicate","reverse","scanl","scanl1","scanr","scanr1","seq","sequence","sequence_","showChar","showParen","showString","shows","snd","span","splitAt","subtract","sum","tail","take","takeWhile","uncurry","undefined","unlines","until","unwords","unzip","unzip3","userError","words","writeFile","zip","zip3","zipWith","zipWith3","||"]
}
