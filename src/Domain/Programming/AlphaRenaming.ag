-----------------------------------------------------------------------------
-- Copyright 2009, Open Universiteit Nederland. This file is distributed 
-- under the terms of the GNU General Public License. For more information, 
-- see the file "LICENSE.txt", which is included in the distribution.
-----------------------------------------------------------------------------
-- |
-- Maintainer  :  alex.gerdes@ou.nl
-- Stability   :  provisional
-- Portability :  unknown
--
-- todo : Testing: a possible test method could be to specify contracts for
--        a number of standard/complete functions and check whether the alpha
--        renamed function still satisfies the contract.
--
-----------------------------------------------------------------------------

INCLUDE "staticanalysis/staticchecks/Scope.ag"
INCLUDE "syntax/UHA_Syntax.ag"

imports{
import Data.List hiding (union, insert, lookup)
import Data.Map hiding (map, filter, (\\))
import Domain.Programming.Helium
import Prelude hiding (lookup)
}

-- Set initialScope
SEM Module
  | Module loc . initialScope = []

-- Copied from StaticChecks, get the names of LHSs
ATTR FunctionBinding FunctionBindings LeftHandSide [ | | name:Name ]

SEM FunctionBindings 
  | Cons  lhs . name = @hd.name
  | Nil   lhs . name = error "AlphaRenaming: empty FunctionBindings"

SEM LeftHandSide
  | Function  lhs . name = @name.self
  | Infix     lhs . name = @operator.self
  | Parenthesized lhs . name = @lefthandside.name

-- Put patternbinding in to scope
SEM Declaration
  | PatternBinding    loc . (namesInScope, unboundNames, scopeInfo) = changeOfScope @pattern.patVarNames @righthandside.unboundNames @lhs.namesInScope
                      lhs . unboundNames = @unboundNames

SEM Body
  | Body loc . (namesInScope, unboundNames, scopeInfo) = changeOfScope @declarations.declVarNames @declarations.unboundNames @lhs.namesInScope
                      lhs . unboundNames = @unboundNames

-- Construct a mapping from vars to vars with fresh names
ATTR Expression RightHandSide
     RecordExpressionBinding RecordExpressionBindings
     MaybeExpression GuardedExpression FunctionBinding
     Expressions Declaration Declarations Alternative FunctionBindings
     Alternatives GuardedExpressions RecordPatternBinding
     Patterns Pattern LeftHandSide RecordPatternBindings AnnotatedType
     AnnotatedTypes Constructor Constructors FieldDeclaration FieldDeclarations Body 
     MaybeDeclarations Statements Statement Qualifier Qualifiers
     [ nameMap : NameMap | freshNames : Names | ]

SEM Module
  | Module body . nameMap    = empty 
                . freshNames = [Name_Identifier noRange [] ('x' : show i) | i <- [1..]]

SEM Body
  | Body loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames

SEM MaybeDeclarations
  | Just loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames

SEM Expression
  | Let loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames
           
SEM Statement
  | Let loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames
           
SEM Qualifier
  | Let loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames

-- monomorphic binding constructs

SEM FunctionBinding
  | FunctionBinding loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames

SEM Expression
  | Lambda loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames

SEM Alternative
  | Alternative loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames
                      
SEM Statement
  | Generator loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames

SEM Qualifier
  | Generator loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames

SEM Declaration
  | PatternBinding loc . (nameMap, freshNames) = updateMap @scopeInfo @lhs.nameMap @namesInScope @lhs.freshNames

-- Do the renaming and make a copy of the ast
ATTR * [ | | result : SELF ]
ATTR Name [ nameMap : NameMap | | ]

SEM Name
  | Identifier Operator Special lhs.result = case lookup @result @lhs.nameMap of
                                               Just n -> n
                                               _      -> @result

-- utility functions
{
type NameMap = Map Name Name

updateMap :: ScopeInfo -> NameMap -> Names -> Names -> (NameMap, Names)
updateMap si m ks vs = let newMap = insertAllInNameMap si m ks vs
                       in (newMap, drop (size newMap - size m) vs)

insertInNameMap :: ScopeInfo -> (Name, Name) -> NameMap -> NameMap
insertInNameMap si (k, v) m | notMember k m  || isShadowed k si = insert k v m
                            | otherwise = m

insertAllInNameMap :: ScopeInfo -> NameMap -> Names -> Names -> NameMap
insertAllInNameMap si m ks = foldr (insertInNameMap si) m . zip ks

isShadowed :: Name -> ScopeInfo -> Bool
isShadowed n = elem n . map fst . (\(_,_,s)->s) 

alphaRenaming :: Module -> Module
alphaRenaming = fst . sem_Module


-- Reserved identifiers, not necessary anymore: the unbounded names are not put into the renaming scheme. 
-- I let them hang around for a while, you never know ;-)
preludeIdentifiers = ["$!","catch","!!","$","&&","++",".","=<<","Bool","False","True","Bounded","minBound","maxBound","Char","Double","Either","Left","Right","Enum","succ","pred","toEnum","fromEnum","enumFrom","enumFromThen","enumFromTo","enumFromThenTo","Eq","==","/=","FilePath","Float","Fractional","pi","exp","sqrt","log","**","logBase","sin","tan","cos","asin","atan","acos","sinh","tanh","cosh","asinh","atanh","acosh","Fractional","/","recip","fromRational","Functor","fmap","IO","IOError","Int","Integer","Integral","quot","rem","div","mod","quotRem","divMod","toInteger","Maybe","Nothing","Just","Monad",">>=",">>","return","fail","Num","+","*","-","negate","abs","signum","fromInteger","Ord","compare","<",">=",">","<=","max","min","Ordering","LT","EQ","GT","Rational","Read","readsPrec","readList","ReadS","Real","toRational","RealFloat","floatRadix","floatDigits","floatRange","decodeFloat","encodeFloat","exponent","significand","scaleFloat","isNaN","isInfinite","isDenormalized","isNegativeZero","isIEEE","atan2","RealFrac","properFraction","truncate","round","ceiling","floor","Show","showsPrec","show","showList","ShowS","String","^","^^","all","and","any","appendFile","asTypeOf","break","concat","concatMap","const","curry","cycle","drop","dropWhile","either","elem","error","even","filter","flip","foldl","foldl1","foldr","foldr1","fromIntegral","fst","gcd","getChar","getContents","getLine","head","id","init","interact","ioError","iterate","last","lcm","length","lex","lines","lookup","map","mapM","mapM_","maximum","maybe","minimum","not","notElem","null","odd","or","otherwise","print","product","putChar","putStr","putStrLn","read","readFile","readIO","readLn","readParen","reads","realToFrac","repeat","replicate","reverse","scanl","scanl1","scanr","scanr1","seq","sequence","sequence_","showChar","showParen","showString","shows","snd","span","splitAt","subtract","sum","tail","take","takeWhile","uncurry","undefined","unlines","until","unwords","unzip","unzip3","userError","words","writeFile","zip","zip3","zipWith","zipWith3","||"]
}
